description = '''
Игра «Жизнь» Конвея — клеточный автомат для имитационного моделирования, позволяющий создавать 
интересные узоры на основе простых правил. 
Изобрел ее математик Джон Конвей в 1970 году, а сделала известной рубрика «Математические игры» Мартина Гарднера 
в журнале Scientific American. 
Программисты и специалисты по вычислительной технике сегодня очень любят эту скорее интересную визуализацию, 
чем настоящую «игру». 
Двумерная доска содержит сетку из «клеток», которые все следуют трем простым правилам:
- живые клетки с двумя или тремя соседями остаются живыми на следующем шаге моделирования;
- мертвые клетки с ровно тремя соседями оживают на следующем шаге моделирования;
- все прочие клетки умирают или остаются мертвыми на следующем шаге моделирования.
Состояние клетки на следующем шаге моделирования (живая или мертвая) зависит только от текущего состояния. 
Клетки не «помнят» старых состояний. Существует множество исследований, посвященных узорам, генерируемым 
на основе этих простых правил. 
'''

import copy, random, sys, time

print(description)
input('Нажмите ENTER для продолжения.')

# константы
WIDTH = 79 # ширина сетки клеток
HEIGHT = 20 # высота сетки клеток
ALIVE = 'O' # символ живой клетки
# ALIVE = '|' # символ живой клетки
DEAD = ' ' # символ мертвой клетки
# DEAD = '-' # символ мертвой клетки
# (!) Попробуйте заменить значение ALIVE на '|', а DEAD на '-'.

# cells и nextCells — ассоциативные массивы для хранения состояния игры.
# Роль их ключей играют кортежи (x, y), а значения представляют собой
# одно из значений ALIVE или DEAD.
nextCells = {}
# Вставляем в nextCells случайные живые и мертвые клетки:
for x in range(WIDTH): # по всем столбцам
    for y in range(HEIGHT): # по всем строкам
        # вероятность живая или мертвая 50:
        if random.randint(0, 1) == 0:
            nextCells[(x, y)] = ALIVE
        else:
            nextCells[(x, y)] = DEAD

# Основной цикл программы
# Итерации этого цикла соответствуют шагам моделирования.
while True:
    # print('\n' * 50) # Разделяем шаги символами новой строки. (новый кадр)
    cells = copy.deepcopy(nextCells)

    # Выводим клетки на экран:
    for y in range(HEIGHT):
        for x in range(WIDTH):
            print(cells[(x, y)], end='') # Выводим # или пробел.
        print()  # Выводим символ новой строки в конце строки.
    print('Нажмите Ctrl-C для выхода из программы.')

    # Вычисляем клетки следующего шага исходя из клеток на текущем шаге:
    for x in range(WIDTH):
        for y in range(HEIGHT):
            # Получаем координаты (x, y) соседних клеток, даже если они выходят за границы:
            left  = (x - 1) % WIDTH
            right = (x + 1) % WIDTH
            above = (y - 1) % HEIGHT
            below = (y + 1) % HEIGHT

            # Подсчитываем количество живых соседей:
            numNeighbors = 0
            if cells[(left, above)] == ALIVE:
                numNeighbors += 1  # Сосед вверху слева жив.
            if cells[(x, above)] == ALIVE:
                numNeighbors += 1  # Сосед вверху жив.
            if cells[(right, above)] == ALIVE:
                numNeighbors += 1  # Сосед вверху справа жив.
            if cells[(left, y)] == ALIVE:
                numNeighbors += 1  # Сосед слева жив.
            if cells[(right, y)] == ALIVE:
                numNeighbors += 1  # Сосед справа жив.
            if cells[(left, below)] == ALIVE:
                numNeighbors += 1  # Сосед внизу слева жив.
            if cells[(x, below)] == ALIVE:
                numNeighbors += 1  # Сосед внизу жив.
            if cells[(right, below)] == ALIVE:
                numNeighbors += 1  # Сосед внизу справа жив.

            # Устанавливаем состояние клеток в соответствии с правилами игры
            if cells[(x, y)] == ALIVE and (numNeighbors == 2
                                           or numNeighbors == 3):
                # Живые клетки с двумя или тремя соседями остаются живыми:
                nextCells[(x, y)] = ALIVE
            elif cells[(x, y)] == DEAD and numNeighbors == 3:
                # Мертвые клетки с тремя соседями становятся живыми:
                nextCells[(x, y)] = ALIVE
            else:
                # Все остальные клетки умирают или остаются мертвыми:
                nextCells[(x, y)] = DEAD
    try:
        time.sleep(1)  # Добавляем паузу в 1 секунду, чтобы уменьшить мигание.
    except KeyboardInterrupt:
        print("Conway's Game of Life")
        sys.exit()  # Если нажато Ctrl+C — завершаем программу.